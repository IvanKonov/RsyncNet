using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace RsyncNetTests
{
    using RsyncNet;
    using RsyncNet.Libraries;

    [TestClass]
    public class RollingChecksumTest
    {
        private byte[] _validByteBlock = new byte[]
                                        {
#region BYTES
                                            202, 25, 54, 157, 184, 51, 43, 244, 175, 133, 154, 12, 41, 32, 48, 49, 203, 134
                                            , 98, 237, 246, 48, 98, 215, 63, 178, 234, 62, 222, 219, 41, 155, 19, 41, 180,
                                            58, 218, 250, 202, 181, 102, 80, 252, 130, 204, 22, 82, 115, 187, 73, 51, 13,
                                            81, 25, 222, 54, 130, 34, 125, 42, 200, 77, 196, 117, 121, 56, 145, 120, 151,
                                            109, 49, 159, 50, 49, 223, 186, 174, 192, 250, 187, 189, 2, 8, 14, 96, 248, 126
                                            , 45, 109, 68, 73, 240, 245, 201, 218, 206, 157, 92, 132, 42, 139, 223, 171,
                                            154, 66, 144, 151, 77, 195, 51, 220, 36, 129, 50, 163, 135, 23, 95, 201, 94, 78
                                            , 149, 40, 103, 125, 232, 136, 15, 116, 156, 179, 103, 6, 18, 180, 202, 227,
                                            239, 168, 150, 32, 25, 207, 232, 111, 213, 17, 80, 80, 246, 124, 195, 255, 116,
                                            88, 168, 196, 149, 120, 179, 82, 230, 191, 0, 239, 138, 33, 175, 165, 173, 23,
                                            182, 60, 42, 217, 123, 86, 185, 122, 147, 177, 242, 100, 35, 226, 99, 236, 155,
                                            17, 179, 38, 47, 79, 149, 106, 114, 135, 120, 1, 185, 206, 224, 130, 5, 73, 165
                                            , 76, 222, 70, 176, 218, 93, 193, 172, 189, 217, 101, 211, 12, 197, 231, 72,
                                            201, 206, 81, 166, 74, 98, 164, 222, 80, 234, 131, 201, 173, 36, 5, 204, 17,
                                            167, 84, 177, 200, 180, 252, 160, 13, 37, 131, 57, 20, 235, 18, 138, 13, 209,
                                            140, 88, 155, 58, 191, 113, 104, 61, 156, 56, 14, 71, 131, 148, 161, 53, 4, 121
                                            , 58, 205, 205, 235, 149, 194, 118, 67, 58, 167, 28, 21, 68, 128, 8, 46, 43, 83
                                            , 232, 100, 233, 155, 226, 219, 95, 187, 160, 154, 21, 14, 103, 116, 173, 251,
                                            222, 5, 210, 187, 15, 53, 217, 37, 200, 2, 237, 21, 212, 98, 182, 90, 186, 111,
                                            121, 73, 224, 147, 240, 24, 76, 129, 177, 88, 183, 150, 178, 34, 60, 142, 17,
                                            145, 78, 244, 182, 218, 44, 240, 32, 154, 99, 25, 232, 146, 61, 100, 117, 27,
                                            151, 142, 114, 149, 106, 173, 108, 82, 216, 231, 149, 159, 34, 141, 81, 77, 194
                                            , 32, 141, 178, 154, 149, 201, 118, 25, 39, 78, 171, 33, 174, 244, 39, 38, 87,
                                            12, 239, 14, 154, 10, 34, 142, 22, 27, 90, 151, 73, 168, 135, 91, 21, 129, 166,
                                            121, 71, 217, 211, 130, 30, 7, 148, 151, 106, 187, 238, 224, 83, 124, 188, 71,
                                            45, 190, 178, 10, 113, 82, 245, 92, 201, 171, 207, 39, 70, 190, 113, 190, 183,
                                            168, 224, 141, 4, 40, 67, 217, 189, 203, 42, 2, 129, 247, 86, 229, 160, 79, 167
                                            , 224, 49, 92, 255, 209, 46, 44, 241, 38, 194, 154, 86, 98, 105, 98, 50, 93,
                                            144, 75, 99, 40, 113, 223, 6, 197, 129, 55, 45, 128, 107, 96, 235, 172, 128,
                                            140, 232, 105, 255, 100, 10, 20, 44, 3, 10, 43, 10, 30, 40, 22, 4, 6, 12, 232
#endregion
                                        };

        [TestMethod]
        public void Checksums_are_equal_for_full_block_and_rolling_updates()
        {
            uint blockSize = 500;
            var genA = new RollingChecksum();
            int start = 10;
            int rolls = 4;
            genA.ProcessBlock(_validByteBlock, (uint) start, blockSize);
            for (var i = 0; i < rolls; ++i)
                genA.RollByte(_validByteBlock[start + blockSize + i]);
            var genB = new RollingChecksum();
            genB.ProcessBlock(_validByteBlock, (uint) (start + rolls), blockSize);
            Assert.AreEqual(genA.Value, genB.Value);
        }

        [TestMethod]
        public void Checksums_are_equal_for_two_whole_block_updates()
        {
            var genA = new RollingChecksum();
            genA.ProcessBlock(_validByteBlock, 0, 500);
            var genB = new RollingChecksum();
            genB.ProcessBlock(_validByteBlock, 0, 500);
            Assert.AreEqual(genA.Value, genB.Value);
        }

        [TestMethod]
        public void Trim_updates_value_correctly()
        {
            var genA = new RollingChecksum();
            genA.ProcessBlock(_validByteBlock, 0, 501);
            genA.TrimFront();
            var genB = new RollingChecksum();
            genB.ProcessBlock(_validByteBlock, 1, 500);
            Assert.AreEqual(genA.Value, genB.Value);
        }

        [TestMethod]
        public void Non_equal_blocks_yield_different_result()
        {
            var sourceBytes = new byte[]
                                  {
#region BYTES
                                      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254, 255, 254, 254
#endregion
                                  };

            var genA = new RollingChecksum();
            genA.ProcessBlock(sourceBytes, 0, (uint)sourceBytes.Length);

            var destinationBytes = new byte[]
                                       {
#region BYTES
                                           255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255
#endregion
                                       };

            var genB = new RollingChecksum();
            genB.ProcessBlock(destinationBytes, 0, (uint)destinationBytes.Length);
        
            Assert.AreNotEqual(genA.Value, genB.Value);
        }
    }
}
